SBCL(1)                                                                                                                                                           General Commands Manual                                                                                                                                                           SBCL(1)

NNAAMMEE
       SBCL -- Steel Bank Common Lisp

DDEESSCCRRIIPPTTIIOONN
       SBCL is an implementation of ANSI Common Lisp, featuring a high-performance native compiler, native threads on several platforms, a socket interface, a source-level debugger, a statistical profiler, and much more.

       It is free software, mostly in the public domain, but with some subsystems under BSD-style licenses which allow modification and reuse as long as credit is given. It is provided "as is", with no warranty of any kind.

       For more information about license issues, see the COPYING file in the distribution. For more information about history, see the CREDITS file in the distribution.

RRUUNNNNIINNGG SSBBCCLL
       To run SBCL, type "sbcl". After startup messages a prompt ("*") appears. Enter a Lisp expression, and SBCL will read and execute it, print any values returned, give you another prompt, and wait for your next input.

         $ sbcl
         ...[startup messages elided]...
         * (+ 1 2 3)

         6
         * (exit)

       Most people like to run SBCL as a subprocess under Emacs. The Emacs "Slime" mode provides many convenient features, like command line editing, tab completion, and various kinds of coupling between Common Lisp source files and the interactive SBCL subprocess.

       For information on creating "standalone executables" using SBCL, see SB-EXT:SAVE-LISP-AND-DIE in the User Manual.

CCOOMMMMAANNDD LLIINNEE SSYYNNTTAAXX
       For ordinary interactive use, no command line arguments should be necessary.

       In order to understand the SBCL command line syntax, it is helpful to understand that the system is composed of two parts: a runtime environment, and the Common Lisp system it supports. Some command line arguments are processed during the initialization of the runtime, and some during the initialization of the Lisp system -- any remaining
       command line arguments are passed on to user code.

       The overall command line syntax is:

              ssbbccll [[rruunnttiimmee ooppttiioonnss]] ----eenndd--rruunnttiimmee--ooppttiioonnss [[ttoopplleevveell ooppttiioonnss]] ----eenndd--ttoopplleevveell--ooppttiioonnss [[uusseerr ooppttiioonnss]]

       Both --end-runtime-options and --end-toplevel-options are optional, and may be omitted. They are intended for use in situations where any command line options are under user control (_e_._g_. in batch files): by using them you can prevent options intended for your program being accidentally processed by SBCL.

       Supported runtime options are

       ----ccoorree <<ccoorreeffiilleennaammee>>
          Use the specified Lisp core file instead of the default. (See the FILES section for the standard core, or the system documentation for SB-EXT:SAVE-LISP-AND-DIE for information about how to create a custom core.) Note that if the Lisp core file is a user-created core file, it may run a nonstandard toplevel which does not  recognize  the
          standard toplevel options.

       ----ddyynnaammiicc--ssppaaccee--ssiizzee <<mmeeggaabbyytteess>>
          Size of the dynamic space reserved on startup in megabytes. Default value is platform dependent.

       ----ccoonnttrrooll--ssttaacckk--ssiizzee <<mmeeggaabbyytteess>>
          Size of control stack reserved for each thread in megabytes. Default value is 2.

       ----nnooiinnffoorrmm
          Suppress the printing of any banner or other informational message at startup. (This makes it easier to write Lisp programs which work cleanly in Unix pipelines. See also the "--noprint" and "--disable-debugger" options.)

       ----ddiissaabbllee--llddbb
          Disable the low-level debugger. Only effective if SBCL is compiled with LDB.

       ----lloossee--oonn--ccoorrrruuppttiioonn
          There  are  some dangerous low level errors (for instance, control stack exhausted, memory fault) that (or whose handlers) can corrupt the image. By default SBCL prints a warning, then tries to continue and handle the error in Lisp, but this will not always work and SBCL may malfunction or even hang. With this option, upon encountering
          such an error SBCL will invoke ldb (if present and enabled) or else exit.

       ----ssccrriipptt <<ffiilleennaammee>>
          As a runtime option equivalent to --noinform --disable-ldb --lose-on-corruption --end-runtime-options --script <filename>. See the description of --script as a toplevel option below.

       ----mmeerrggee--ccoorree--ppaaggeess
          When platform support is present, provide hints to the operating system that identical pages may be shared between processes until they are written to. This can be useful to reduce the memory usage on systems with multiple SBCL processes started from similar but differently-named core files, or from compressed cores.  Without  platform
          support, do nothing. By default only compressed cores trigger hinting.

       ----nnoo--mmeerrggee--ccoorree--ppaaggeess
          Ensures that no sharing hint is provided to the operating system.

       ----hheellpp
          Print some basic information about SBCL, then exit.

       ----vveerrssiioonn
          Print SBCL's version information, then exit.

       In the future, runtime options may be added to control behavior such as lazy allocation of memory.

       Runtime options, including any --end-runtime-options option, are stripped out of the command line before the Lisp toplevel logic gets a chance to see it.

       The toplevel options supported by the standard SBCL core are

       ----ssyyssiinniitt <<ffiilleennaammee>>
          Load filename instead of the default system-wide initialization file.  (See the FILES section.)

       ----nnoo--ssyyssiinniitt
          Do not load a system-wide initialization file. If this option is given, the --sysinit option is ignored.

       ----uusseerriinniitt <<ffiilleennaammee>>
          Load filename instead of the default user initialization file. (See the FILES section.)

       ----nnoo--uusseerriinniitt
          Do not load a user initialization file. If this option is given, the --userinit option is ignored.

       ----eevvaall <<ccoommmmaanndd>>
          After executing any initialization file, but before starting the read-eval-print loop on standard input, read and evaluate the command given. More than one --eval option can be used, and all will be read and executed, in the order they appear on the command line.

       ----llooaadd <<ffiilleennaammee>>
          This is equivalent to --eval '(load "<filename>")'. The special syntax is intended to reduce quoting headaches when invoking SBCL from shell scripts.

       ----nnoopprriinntt
          When ordinarily the toplevel "read-eval-print loop" would be executed, execute a "read-eval loop" instead, _i_._e_. don't print a prompt and don't echo results. Combined with the --noinform runtime option, this makes it easier to write Lisp "scripts" which work cleanly in Unix pipelines.

       ----ddiissaabbllee--ddeebbuuggggeerr
          By default when SBCL encounters an error, it enters the builtin debugger, allowing interactive diagnosis and possible intercession.  This option disables the debugger, causing errors to print a backtrace and exit with status 1 instead -- which is a mode of operation better suited for batch processing. See the User Manual on SB-EXT:DIS‐
          ABLE-DEBUGGER for details.

       ----qquuiitt
          At the end of toplevel option processing, exit SBCL with a successful code of zero.  Note that the effect of this option is delayed until after toplevel options following this one.

       ----nnoonn--iinntteerraaccttiivvee
          This option disables the read-eval-print loop for both exceptional and non-exceptional reasons.  It is short for --disable-debugger and --quit in combination and is useful for batch uses where the special option processing implied by --script is not desired.

       ----ssccrriipptt <<ffiilleennaammee>>
          Implies --no-sysinit --no-userinit --disable-debugger --end-toplevel-options.

          Causes the system to load the specified file and exit immediately afterwards, instead of entering the read-eval-print loop. If the file begins with a shebang line, it is ignored.

       Regardless of the order in which toplevel options appear on the command line, the order of actions is:

       1. Debugger is disabled, if requested.

       2. Any system initialization file is loaded, unless prohibited.

       3. Any user initialization file is loaded, unless prohibited.

       4. --eval and --load options are processed in the order given.

       Finally, either the read-eval-print loop is entered or the file specified with --script option is loaded.

       When running in the read-eval-print loop the system exits on end of file. Similarly, the system exits immediately after processing the file specified with --script.

       Note that when running SBCL with the --core option, using a core file created by a user call to the SB-EXT:SAVE-LISP-AND-DIE, the toplevel options may be under the control of user code passed as arguments to SB-EXT:SAVE-LISP-AND-DIE. For this purpose, the --end-toplevel-options option itself can be considered a toplevel option,  _i_._e_.  the
       user core, at its option, may not support it.

       In the standard SBCL startup sequence (_i_._e_. with no user core involved) toplevel options and any --end-toplevel-options option are stripped out of the command line argument list before user code gets a chance to see it.

OOVVEERRVVIIEEWW
       SBCL is derived from the CMU CL. (The name is intended to acknowledge the connection: steel and banking are the industries where Carnegie and Mellon made the big bucks.)

       SBCL compiles by default: even functions entered in the read-eval-print loop are compiled to native code, unless the evaluator has been explicitly turned on. (Even today, some 40 years after the MacLisp compiler, people will tell you that Lisp is an interpreted language. Ignore them.)

       SBCL aims for but has not completely achieved compliance with the ANSI standard for Common Lisp. More information about this is available in the BUGS section below.

       SBCL also includes various non-ANSI extensions, described more fully in the User Manual.  Some of these are in the base system and others are "contrib" modules loaded on request using REQUIRE.  For example, to load the SB-BSD-SOCKETS module that provides TCP/IP connectivity,
          * (require 'asdf)
          * (require 'sb-bsd-sockets)

       For more information, see the User Manual.

TTHHEE CCOOMMPPIILLEERR
       SBCL  inherits  from  CMU CL the "Python" native code compiler. (Though we often avoid that name in order to avoid confusion with the scripting language also called Python.) This compiler is very clever about understanding the type system of Common Lisp and using it to optimize code, and about producing notes to let the user know when the
       compiler doesn't have enough type information to produce efficient code. It also tries (almost always successfully) to follow the unusual but very useful principle that "declarations are assertions", _i_._e_.  type declarations should be checked at runtime unless the user explicitly tells the system that speed is more important than safety.

       The compiled code uses garbage collection to automatically manage memory. The garbage collector implementation varies considerably from CPU to CPU. In particular, on some CPUs the GC is nearly exact, while on others it's more conservative, and on some CPUs the GC is generational, while on others simpler stop and copy strategies are used.

       For more information about the compiler, see the user manual.

SSYYSSTTEEMM RREEQQUUIIRREEMMEENNTTSS
       SBCL currently runs on X86 (Linux, FreeBSD, OpenBSD, and NetBSD), X86-64 (Linux), Alpha (Linux, Tru64), PPC (Linux, Darwin/MacOS X), SPARC (Linux and Solaris 2.x), and MIPS (Linux). For information on other ongoing and possible ports, see the sbcl-devel mailing list, and/or the web site.

       SBCL requires on the order of 16Mb RAM to run on X86 systems, though all but the smallest programs would be happier with 32Mb or more.

KKNNOOWWNN BBUUGGSS
       This section attempts to list the most serious and long-standing bugs.  For more detailed and current information on bugs, see the BUGS file in the distribution.

       It is possible to get in deep trouble by exhausting heap memory.  The SBCL system overcommits memory at startup, so, on typical Unix-alikes like Linux and FreeBSD, this means that if the SBCL system turns out to use more virtual memory than the system has available for it, other processes tend to be killed randomly (!).

       The compiler's handling of function return values unnecessarily violates the "declarations are assertions" principle that it otherwise adheres to. Using PROCLAIM or DECLAIM to specify the return type of a function causes the compiler to believe you without checking. Thus compiling a file containing
         (DECLAIM (FTYPE (FUNCTION (T) NULL) SOMETIMES))
         (DEFUN SOMETIMES (X) (ODDP X))
         (DEFUN FOO (X) (IF (SOMETIMES X) 'THIS-TIME 'NOT-THIS-TIME))
       then running (FOO 1) gives NOT-THIS-TIME, because the compiler relied on the truth of the DECLAIM without checking it.

       Some things are implemented very inefficiently.

       -- Multidimensional arrays are inefficient, especially multidimensional arrays of floating point numbers.

       -- SBCL, like most (maybe all?) implementations of Common Lisp on stock hardware, has trouble passing floating point numbers around efficiently, because a floating point number, plus a few extra bits to identify its type, is larger than a machine word. (Thus, they get "boxed" in heap-allocated storage, causing GC overhead.) Within a  sin‐
          gle  compilation  unit, or when doing built-in operations like SQRT and AREF, or some special operations like structure slot accesses, this is avoidable: see the user manual for some efficiency hints. But for general function calls across the boundaries of compilation units, passing the result of a floating point calculation as a func‐
          tion argument (or returning a floating point result as a function value) is a fundamentally slow operation.

RREEPPOORRTTIINNGG BBUUGGSS
       To report a bug, please send mail to the mailing lists sbcl-help or sbcl-devel. You can find the complete mailing list addresses on the web pages at <http://sbcl.sourceforge.net/>; note that as a spam reduction measure you must subscribe to the lists before you can post. (You may also find fancy SourceForge bug-tracking  machinery  there,
       but don't be fooled. As of 2002-07-25 anyway, we don't actively monitor that machinery, and it exists only because we haven't been able to figure out how to turn it off.)

       As  with any software bug report, it's most helpful if you can provide enough information to reproduce the symptoms reliably, and if you say clearly what the symptoms are.  For example, "There seems to be something wrong with TAN of very small negative arguments. When I execute (TAN LEAST-NEGATIVE-SINGLE-FLOAT) interactively on sbcl-1.2.3
       on my Linux 4.5 X86 box, I get an UNBOUND-VARIABLE error."

DDIIFFFFEERREENNCCEESS FFRROOMM CCMMUU CCLL
       SBCL can be built from scratch using a plain vanilla ANSI Common Lisp system and a C compiler, and all of its properties are specified by the version of the source code that it was created from. This clean bootstrappability was the immediate motivation for forking off of the CMU CL development tree. A variety of implementation differences
       are motivated by this design goal.

       Maintenance work in SBCL since the fork has diverged somewhat from the maintenance work in CMU CL. Many but not all bug fixes and improvements have been shared between the two projects, and sometimes the two projects disagree about what would be an improvement.

       Most extensions supported by CMU CL have been unbundled from SBCL, including Motif support, the Hemlock editor, search paths, the WIRE protocol, various user-level macros and functions (_e_._g_.  LETF, ITERATE, MEMQ, REQUIRED-ARGUMENT), and many others.

       (Why doesn't SBCL support more extensions natively? Why drop all those nice extensions from CMU CL when the code already exists? This is a frequently asked question on the mailing list. There are two principal reasons. First, it's a design philosophy issue: arguably SBCL has done its job by supplying a stable FFI, and the right design de‐
       cision is to move functionality derived from that, like socket support, into separate libraries. Some of these are distributed with SBCL as "contrib" modules, others are distributed as separate software packages by separate maintainers. Second, it's a practical decision - focusing on a smaller number of things will, we hope, let us  do  a
       better job on them.)

SSUUPPPPOORRTT
       Various information about SBCL is available at <http://www.sbcl.org/>. The mailing lists there are the recommended place to look for support.

AAUUTTHHOORRSS
       Dozens of people have made substantial contributions to SBCL and its subsystems, and to the CMU CL system on which it was based, over the years. See the CREDITS file in the distribution for more information.

EENNVVIIRROONNMMEENNTT
       SSBBCCLL__HHOOMMEE This variable controls where files like "sbclrc", "sbcl.core", and the add-on "contrib" systems are searched for.  If it is not set, then sbcl sets it from a compile-time default location which is usually //uussrr//llooccaall//lliibb//ssbbccll// but may have been changed _e_._g_. by a third-party packager.

FFIILLEESS
       _s_b_c_l   executable program containing some low-level runtime support and a loader, used to read sbcl.core

       _s_b_c_l_._c_o_r_e
              dumped memory image containing most of SBCL, to be loaded by the `sbcl' executable.  Looked for in $$SSBBCCLL__HHOOMMEE, unless overridden by the --core option.

       _s_b_c_l_r_c optional system-wide startup script, looked for in $$SSBBCCLL__HHOOMMEE then //eettcc, unless overridden by the --sysinit command line option.

       _._s_b_c_l_r_c
              optional per-user customizable startup script (in user's home directory, or as specified by  --userinit)

SSEEEE AALLSSOO
       Full SBCL documentation is maintained as a Texinfo manual. If it has been installed, the command

              iinnffoo ssbbccll

       should give you access to the complete manual. Depending on your installation it may also be available in HTML and PDF formats in _e_._g_.

              //uussrr//llooccaall//sshhaarree//ddoocc//ssbbccll//

       See the SBCL homepage

              <http://www.sbcl.org/>

       for more information, including directions on how to subscribe to the sbcl-devel and sbcl-help mailing-lists.

7th Edition                                                                                                                                                                $Date$                                                                                                                                                                   SBCL(1)
